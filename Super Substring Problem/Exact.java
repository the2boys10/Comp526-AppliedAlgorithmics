/**
 * Shortest Common Super String Problem 
 * DATA SET 1 (in abba land)
 * @author Leszek A Gasieniec
 */

// find the shortest string which contains 

import java.util.*;


public class Exact
{
	// inspired by Knuth-Morris-Prat Wiki psudo-code.
	private static int[][] testKnuth(String[] s1)
	{
		// create table to store graph weights create extra node to use as base with weights of 0.
		int test[][] = new int[s1.length+1][s1.length+1];
		// for all strings
		for(int l = 0 ; l < s1.length; l++)
		{
			// get the string and convert it to a character array
			char[] W = s1[l].toCharArray();
			// create a array to store adjacency table.
			int[] T = new int[s1[l].length()];
			// the pos of the letter we are
			int pos = 2;
			int cnd = 0;
			T[0] = - 1;
			T[1] = 0;
			// while we have not checked all positions of the text
			while(pos < W.length)
			{
				// if the postion in the index -1 of the word is equal to the current position that the table is matching on
				if(W[pos - 1] == W[cnd])
				{
					// it was the same to increase each pointer by 1 and set the transition to be the next letter.
					cnd = cnd + 1;
					T[pos] = cnd;
					pos = pos + 1;
				}
				// else the position we are looking at was greater than the start and we did not find a match so move
				// our table pointer to the previously known string of the same pattern.
				else if(cnd > 0)
				{
					cnd = T[cnd];
				}
				// else we did not find a match and are at the first index
				else
				{
					// so set the current transition to the start index and look at the next character.
					T[pos] = cnd;
					pos = pos + 1;
				}
			}
			// for every string
			for(int p = 0; p < s1.length; p++)
			{
				// make sure we arn't looking for the pattern in the same string
				if(l==p)
					continue;
				// set pointers to equal 0
				int m = 0;
				int i = 0;
				// while the pattern can still fit inside of the the string
				while(m + i < s1[p].length())
				{
					// if the char in the pattern are currrently looking at matches the char in the other string
					if(s1[l].charAt(i) == s1[p].charAt(m + i))
					{
						// check the next letters
						i = i + 1;
					}
					else
					{
						// else move the character we are looking at within the text to the displacement of the current
						// check within the pattern, minus the transition tables value for the previous match
						m = m + i - T[i];
						// if the letter we are looking at within the text is greater than 0
						if(i > 0)
						{
							// set the letter we are looking at within the pattern to be the transition value for that
							// letter.
							i = T[i];
						}
					}
				}
				// the value of how many letters there are in the word minus the amount of letters we managed to match
				// on (i) is the amount of wasted words i.e weight of the edge.
				test[p+1][l+1] = s1[1].length() - i;
			}
		}
		// return the adjacency matrix.
		return test;
	}


	// method to remove duplicate strings
	private static String[] cleanArray(String[] initialArray)
	{
		// create a hash set and add all strings to it.
		HashSet<String> temp = new HashSet<String>();
		Collections.addAll(temp, initialArray);
		// convert it to an array to remove all duplicates.
		initialArray = temp.toArray(new String[temp.size()]);
		return initialArray;
	}


	// main method to find the superstring
	public static String findOutString(String[] initialArray)
	{
		// remove duplicates from the array
		initialArray = cleanArray(initialArray);
		// create the adjacency matrix
		int[][] weightedTransitionMatrix = testKnuth(initialArray);
		// run the held karp algorithm using the adjacency matrix, tell the algorithm to start from node 0.
		TspDynamicProgrammingIterative test2 = new TspDynamicProgrammingIterative(0, weightedTransitionMatrix);
		// solve the adjacency matrix
		test2.solve();
		// get the tour generated by held karp
		LinkedList<Integer> tour = test2.getTour();
		// create an array of integers to store the tour
		Integer[] test = new Integer[tour.size()];
		// convert the tour to an integer array
		test = tour.toArray(test);
		// the path shouldn't contain the first and last nodes ( the free node)
		int[] pathInt = new int[test.length-2];
		// get all the nodes and put them in a int array apart from the first and last node.
		for(int i = 1; i < test.length-1; i++)
		{
			pathInt[i-1] = test[i];
		}
		// add the corrisponding first nodes string to the stringbuilder
		StringBuilder endString = new StringBuilder(initialArray[pathInt[0] - 1]);
		for(int i = 1 ; i < pathInt.length ; i ++)
		{
			// append only the partial next word depending on the amount of overlap that the current word and the next
			// word have in common.
			endString.append(initialArray[pathInt[i] - 1].substring(initialArray[pathInt[i] - 1].length() - (int) weightedTransitionMatrix[pathInt[i - 1]][pathInt[i]], initialArray[pathInt[i] - 1].length()));
		}
		// return the merged string.
		return endString.toString();
	}
}




/**
 * An implementation of the traveling salesman problem in Java using dynamic
 * programming to improve the time complexity from O(n!) to O(n^2 * 2^n).
 *
 * Time Complexity: O(n^2 * 2^n)
 * Space Complexity: O(n * 2^n)
 *
 * @author William Fiset, william.alexandre.fiset@gmail.com
 * Avaliable at : https://github.com/williamfiset/Algorithms/blob/master/GraphTheory/TspDynamicProgrammingIterative.java
 **/
// Altered by Robert Johnson to improve space complexity
class TspDynamicProgrammingIterative
{
	private final int N, start;
	private final int[][] distance;
	private LinkedList<Integer> tour = new LinkedList<Integer>();
	private int minTourCost = 10000000;
	private boolean ranSolver = false;

	public TspDynamicProgrammingIterative(int[][] distance) {
		this(0, distance);
	}

	public TspDynamicProgrammingIterative(int start, int[][] distance) {
		N = distance.length;

		if (N <= 2) throw new IllegalStateException("N <= 2 not yet supported.");
		if (N != distance[0].length) throw new IllegalStateException("Matrix must be square (n x n)");
		if (start < 0 || start >= N) throw new IllegalArgumentException("Invalid start node.");

		this.start = start;
		this.distance = distance;
	}

	// Returns the optimal tour for the traveling salesman problem.
	public LinkedList<Integer> getTour() {
		if (!ranSolver) solve();
		return tour;
	}

	// Returns the minimal tour cost.
	public int getTourCost() {
		if (!ranSolver) solve();
		return minTourCost;
	}

	// Solves the traveling salesman problem and caches solution.
	public void solve() {

		if (ranSolver) return;

		final int END_STATE = (1 << N) - 1;
		int[][] memo = new int[N-1][(int)Math.pow(2,distance.length)/4];

		// Add all outgoing edges from the starting node to memo table.
		for (int end = 0; end < N; end++)
		{
			if (end == start) continue;
			int temp = (1 << start) | (1 << end);
			temp = convert(end, temp);
			memo[end-1][temp] = distance[start][end];
		}

		for (int r = 3; r <= N; r++) {
			for (int subset : combinations(r, N)) {
				if (notIn(start, subset)) continue;
				for (int next = 0; next < N; next++) {
					if (next == start || notIn(next, subset)) continue;
					int subsetWithoutNext = subset ^ (1 << next);
					int minDist = 50000;
					for (int end = 0; end < N; end++) {
						if (end == start || end == next || notIn(end, subset)) continue;
						int temp = subsetWithoutNext;
						temp = convert(end, temp);
						int newDistance = memo[end-1][temp] + distance[end][next];
						if (newDistance < minDist) {
							minDist = newDistance;
						}
					}
					int temp = subset;
					temp = convert(next, temp);
					memo[next-1][temp] = minDist;
				}
			}
		}

		// Connect tour back to starting node and minimize cost.
		for (int i = 0; i < N; i++) {
			if (i == start) continue;
			int temp = END_STATE;
			temp = convert(i, temp);
			int tourCost = memo[i-1][temp] + distance[i][start];
			if (tourCost < minTourCost) {
				minTourCost = tourCost;
			}
		}

		int lastIndex = start;
		int state = END_STATE;
		tour.add(start);

		// Reconstruct TSP path from memo table.
		for (int i = 1; i < N; i++) {

			int index = -1;
			for (int j = 0; j < N; j++) {
				if (j == start || notIn(j, state)) continue;
				if (index == -1) index = j;
				int temp = state;
				temp = convert(index, temp);
				int temp2 = state;
				temp2 = convert(j, temp2);
				double prevDist = memo[index-1][temp] + distance[index][lastIndex];
				double newDist  = memo[j-1][temp2] + distance[j][lastIndex];
				if (newDist < prevDist) {
					index = j;
				}
			}
			tour.add(index);
			state = state ^ (1 << index);
			lastIndex = index;
		}
		tour.add(start);
		Collections.reverse(tour);
		ranSolver = true;
	}

	private static boolean notIn(int elem, int subset) {
		return ((1 << elem) & subset) == 0;
	}

	// This method generates all bit sets of size n where r bits
	// are set to one. The result is returned as a list of integer masks.
	public static List<Integer> combinations(int r, int n) {
		List<Integer> subsets = new ArrayList<>();
		combinations(0, 0, r, n, subsets);
		return subsets;
	}

	// To find all the combinations of size r we need to recurse until we have
	// selected r elements (aka r = 0), otherwise if r != 0 then we still need to select
	// an element which is found after the position of our last selected element
	private static void combinations(int set, int at, int r, int n, List<Integer> subsets) {

		// Return early if there are more elements left to select than what is available.
		int elementsLeftToPick = n - at;
		if (elementsLeftToPick < r) return;

		// We selected 'r' elements so we found a valid subset!
		if (r == 0) {
			subsets.add(set);
		} else {
			for (int i = at; i < n; i++) {
				// Try including this element
				set |= 1 << i;

				combinations(set, i + 1, r - 1, n, subsets);

				// Backtrack and try the instance where we did not include this element
				set &= ~(1 << i);
			}
		}
	}

	public static int convert(int i, int number)
	{
		return ((number % (1<<i)) + (int)Math.floor(number/((1<<i)*2))*(1<<i))/2;

	}
}



